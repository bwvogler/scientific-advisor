import logging
from typing import Dict, Any, Optional
from datetime import datetime

from ...api.schemas.models import Document, MemoryEntry, MemoryCreate, MemoryUpdate
from ...core.memory.vector_store import VectorStore
from ...core.rag.rag_engine import RAGEngine
from ...core.llm.ollama_client import OllamaClient
from ...ingestion.processors.document_processor import DocumentIngestionService

logger = logging.getLogger(__name__)

class ScientificAdvisorAgent:
    """Main agent class that orchestrates all components."""
    
    def __init__(self):
        # Initialize core components
        self.vector_store = VectorStore()
        self.llm_client = OllamaClient()
        self.rag_engine = RAGEngine(self.vector_store, self.llm_client)
        self.document_processor = DocumentIngestionService()
        
        logger.info("Scientific Advisor Agent initialized")
    
    async def process_document(self, filename: str, file_content: bytes,
                             customer: Optional[str] = None,
                             project: Optional[str] = None,
                             metadata: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Process and ingest a document into the knowledge base."""
        try:
            # Process the document
            document = self.document_processor.process_document(
                filename=filename,
                file_content=file_content,
                customer=customer,
                project=project,
                metadata=metadata
            )
            
            # Save document file
            file_path = await self.document_processor.save_document_file(document, file_content)
            
            # Add to vector store
            memory_ids = self.vector_store.add_document(document)
            
            logger.info(f"Successfully processed document: {filename}")
            
            return {
                "document_id": document.id,
                "filename": document.filename,
                "content_length": len(document.content),
                "chunks_created": len(memory_ids),
                "file_path": file_path,
                "customer": document.customer,
                "project": document.project
            }
            
        except Exception as e:
            logger.error(f"Failed to process document {filename}: {e}")
            raise
    
    async def query_agent(self, question: str, conversation_id: Optional[str] = None,
                         filters: Optional[Dict[str, Any]] = None,
                         max_results: int = 5) -> Dict[str, Any]:
        """Query the agent with a question."""
        try:
            from ...api.schemas.models import Query
            
            query = Query(
                question=question,
                conversation_id=conversation_id,
                filters=filters,
                max_results=max_results
            )
            
            response = await self.rag_engine.query(query)
            
            return {
                "answer": response.answer,
                "sources": [
                    {
                        "id": source.id,
                        "content": source.content[:200] + "..." if len(source.content) > 200 else source.content,
                        "customer": source.customer,
                        "project": source.project,
                        "source_document_id": source.source_document_id,
                        "similarity_score": getattr(source, 'similarity_score', 0.0)
                    }
                    for source in response.sources
                ],
                "conversation_id": response.conversation_id,
                "query_time_ms": response.query_time_ms,
                "tokens_used": response.tokens_used
            }
            
        except Exception as e:
            logger.error(f"Failed to query agent: {e}")
            raise
    
    async def add_memory(self, memory_data: MemoryCreate) -> str:
        """Add a manual memory entry."""
        try:
            memory_entry = MemoryEntry(
                id="",  # Will be generated by vector store
                content=memory_data.content,
                customer=memory_data.customer,
                project=memory_data.project,
                date=datetime.utcnow(),
                source_document_id="manual_entry",
                chunk_index=0,
                importance_score=memory_data.importance_score,
                metadata=memory_data.metadata
            )
            
            memory_id = self.vector_store.add_memory_entry(memory_entry)
            
            logger.info(f"Added manual memory entry: {memory_id}")
            return memory_id
            
        except Exception as e:
            logger.error(f"Failed to add memory: {e}")
            raise
    
    async def update_memory(self, memory_id: str, updates: MemoryUpdate) -> bool:
        """Update a memory entry."""
        try:
            update_dict = {}
            
            if updates.content is not None:
                update_dict["content"] = updates.content
            if updates.customer is not None:
                update_dict["customer"] = updates.customer
            if updates.project is not None:
                update_dict["project"] = updates.project
            if updates.importance_score is not None:
                update_dict["importance_score"] = updates.importance_score
            if updates.metadata is not None:
                update_dict["metadata"] = updates.metadata
            
            success = self.vector_store.update_memory_entry(memory_id, update_dict)
            
            if success:
                logger.info(f"Updated memory entry: {memory_id}")
            else:
                logger.warning(f"Memory entry not found: {memory_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to update memory {memory_id}: {e}")
            raise
    
    async def delete_memory(self, memory_id: str) -> bool:
        """Delete a memory entry."""
        try:
            success = self.vector_store.delete_memory_entry(memory_id)
            
            if success:
                logger.info(f"Deleted memory entry: {memory_id}")
            else:
                logger.warning(f"Memory entry not found: {memory_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete memory {memory_id}: {e}")
            raise
    
    async def get_memory(self, memory_id: str) -> Optional[Dict[str, Any]]:
        """Get a specific memory entry."""
        try:
            memory_entry = self.vector_store.get_memory_entry(memory_id)
            
            if memory_entry:
                return {
                    "id": memory_entry.id,
                    "content": memory_entry.content,
                    "customer": memory_entry.customer,
                    "project": memory_entry.project,
                    "date": memory_entry.date,
                    "source_document_id": memory_entry.source_document_id,
                    "chunk_index": memory_entry.chunk_index,
                    "importance_score": memory_entry.importance_score,
                    "metadata": memory_entry.metadata,
                    "created_at": memory_entry.created_at
                }
            
            return None
            
        except Exception as e:
            logger.error(f"Failed to get memory {memory_id}: {e}")
            raise
    
    async def list_memories(self, limit: int = 100, offset: int = 0,
                          filters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """List memory entries."""
        try:
            memory_entries = self.vector_store.list_memory_entries(limit, offset, filters)
            stats = self.vector_store.get_stats()
            
            return {
                "memories": [
                    {
                        "id": entry.id,
                        "content": entry.content,
                        "customer": entry.customer,
                        "project": entry.project,
                        "date": entry.date,
                        "source_document_id": entry.source_document_id,
                        "importance_score": entry.importance_score,
                        "metadata": entry.metadata,
                        "created_at": entry.created_at
                    }
                    for entry in memory_entries
                ],
                "total_count": stats["total_entries"],
                "returned_count": len(memory_entries),
                "offset": offset,
                "limit": limit
            }
            
        except Exception as e:
            logger.error(f"Failed to list memories: {e}")
            raise
    
    async def get_conversations(self, limit: int = 50, offset: int = 0) -> Dict[str, Any]:
        """Get conversation history."""
        try:
            conversations = self.rag_engine.list_conversations(limit, offset)
            
            return {
                "conversations": [
                    {
                        "id": conv.id,
                        "title": conv.title,
                        "customer": conv.customer,
                        "project": conv.project,
                        "message_count": len(conv.messages),
                        "created_at": conv.created_at,
                        "updated_at": conv.updated_at
                    }
                    for conv in conversations
                ],
                "total_count": len(self.rag_engine.conversations),
                "returned_count": len(conversations),
                "offset": offset,
                "limit": limit
            }
            
        except Exception as e:
            logger.error(f"Failed to get conversations: {e}")
            raise
    
    async def create_conversation(self, title: Optional[str] = None,
                                customer: Optional[str] = None,
                                project: Optional[str] = None) -> Dict[str, Any]:
        """Create a new conversation."""
        try:
            conversation = self.rag_engine.create_conversation(title, customer, project)
            
            return {
                "id": conversation.id,
                "title": conversation.title,
                "customer": conversation.customer,
                "project": conversation.project,
                "created_at": conversation.created_at,
                "updated_at": conversation.updated_at
            }
            
        except Exception as e:
            logger.error(f"Failed to create conversation: {e}")
            raise
    
    async def delete_conversation(self, conversation_id: str) -> bool:
        """Delete a conversation."""
        try:
            success = self.rag_engine.delete_conversation(conversation_id)
            
            if success:
                logger.info(f"Deleted conversation: {conversation_id}")
            else:
                logger.warning(f"Conversation not found: {conversation_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Failed to delete conversation {conversation_id}: {e}")
            raise
    
    async def health_check(self) -> Dict[str, Any]:
        """Perform a health check of all components."""
        try:
            # Check Ollama connection
            ollama_available = await self.llm_client.is_available()
            
            # Check vector store
            stats = self.vector_store.get_stats()
            
            return {
                "status": "healthy" if ollama_available else "degraded",
                "ollama_connected": ollama_available,
                "chroma_connected": True,  # If we got here, it's working
                "total_memory_entries": stats["total_entries"],
                "total_documents": 0,  # TODO: Track document count
                "model": self.llm_client.model,
                "embedding_model": "sentence-transformers"
            }
            
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return {
                "status": "unhealthy",
                "error": str(e),
                "ollama_connected": False,
                "chroma_connected": False,
                "total_memory_entries": 0,
                "total_documents": 0
            }
    
    async def close(self):
        """Close all connections."""
        try:
            await self.llm_client.close()
            logger.info("Scientific Advisor Agent closed")
        except Exception as e:
            logger.error(f"Error closing agent: {e}")
